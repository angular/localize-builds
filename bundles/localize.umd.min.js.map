{"version":3,"sources":["packages/localize/localize.umd.js"],"names":["factory","define","amd","__globalThis","globalThis","__window","window","__self","self","WorkerGlobalScope","__global","global","$localize","messageParts","expressions","_i","arguments","length","translate","translation","messagePart","message","i","raw","charAt","substring","indexOf"],"mappings":";;;;;CAMC,SAAUA,GACW,mBAAXC,QAAyBA,OAAOC,IAAMD,OAAO,oBAAqBD,GACzEA,IAFJ,CAGE,WAAc;;;;;;;OASZ,IAAIG,EAAqC,oBAAfC,YAA8BA,WACpDC,EAA6B,oBAAXC,QAA0BA,OAC5CC,EAAyB,oBAATC,MAAqD,oBAAtBC,mBAC/CD,gBAAgBC,mBAAqBD,KACrCE,EAA6B,oBAAXC,QAA0BA,OAoE5CC,EAAY,SAAUC,GAEtB,IADA,IAAIC,EAAc,GACTC,EAAK,EAAGA,EAAKC,UAAUC,OAAQF,IACpCD,EAAYC,EAAK,GAAKC,UAAUD,GAEpC,GAAIH,EAAUM,UAAW,CAErB,IAAIC,EAAcP,EAAUM,UAAUL,EAAcC,GACpDD,EAAeM,EAAY,GAC3BL,EAAcK,EAAY,GAG9B,IADA,IA4B0BC,EA5BtBC,EAAUR,EAAa,GAClBS,EAAI,EAAGA,EAAIT,EAAaI,OAAQK,IACrCD,GAAWP,EAAYQ,EAAI,IA0BLF,EA1B+BP,EAAaS,GApE5C,OAoEgDT,EAAaU,IAAID,IA2BjEF,GAAaI,OAAO,GAC1CJ,EAAYK,UAAUL,EAAYM,QAhGZ,IAgG6C,GAAK,GACxEN,GA3BJ,OAAOC;;;;;;;;CA/EGlB,GAAgBO,GAAYL,GAAYE,GAqH9CK,UAAYA","sourcesContent":["/**\n * @license Angular v9.0.0-next.5+59.sha-e38351f.with-local-changes\n * (c) 2010-2019 Google LLC. https://angular.io/\n * License: MIT\n */\n\n(function (factory) {\n    typeof define === 'function' && define.amd ? define('@angular/localize', factory) :\n    factory();\n}(function () { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __globalThis = typeof globalThis !== 'undefined' && globalThis;\n    var __window = typeof window !== 'undefined' && window;\n    var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self;\n    var __global = typeof global !== 'undefined' && global;\n    // Always use __globalThis if available; this is the spec-defined global variable across all\n    // environments.\n    // Then fallback to __global first; in Node tests both __global and __window may be defined.\n    var _global = __globalThis || __global || __window || __self;\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var PLACEHOLDER_NAME_MARKER = ':';\n    /**\n     * Tag a template literal string for localization.\n     *\n     * For example:\n     *\n     * ```ts\n     * $localize `some string to localize`\n     * ```\n     *\n     * **Naming placeholders**\n     *\n     * If the template literal string contains expressions then you can optionally name the placeholder\n     * associated with each expression. Do this by providing the placeholder name wrapped in `:`\n     * characters directly after the expression. These placeholder names are stripped out of the\n     * rendered localized string.\n     *\n     * For example, to name the `item.length` expression placeholder `itemCount` you write:\n     *\n     * ```ts\n     * $localize `There are ${item.length}:itemCount: items`;\n     * ```\n     *\n     * If you need to use a `:` character directly an expression you must either provide a name or you\n     * can escape the `:` by preceding it with a backslash:\n     *\n     * For example:\n     *\n     * ```ts\n     * $localize `${label}:label:: ${}`\n     * // or\n     * $localize `${label}\\: ${}`\n     * ```\n     *\n     * **Processing localized strings:**\n     *\n     * There are three scenarios:\n     *\n     * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a transpiler,\n     * removing the tag and replacing the template literal string with a translated literal string\n     * from a collection of translations provided to the transpilation tool.\n     *\n     * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and reorders\n     * the parts (static strings and expressions) of the template literal string with strings from a\n     * collection of translations loaded at run-time.\n     *\n     * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n     * the original template literal string without applying any translations to the parts. This version\n     * is used during development or where there is no need to translate the localized template\n     * literals.\n     *\n     * @param messageParts a collection of the static parts of the template string.\n     * @param expressions a collection of the values of each placeholder in the template string.\n     * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n     */\n    var $localize = function (messageParts) {\n        var expressions = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            expressions[_i - 1] = arguments[_i];\n        }\n        if ($localize.translate) {\n            // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n            var translation = $localize.translate(messageParts, expressions);\n            messageParts = translation[0];\n            expressions = translation[1];\n        }\n        var message = messageParts[0];\n        for (var i = 1; i < messageParts.length; i++) {\n            message += expressions[i - 1] + stripPlaceholderName(messageParts[i], messageParts.raw[i]);\n        }\n        return message;\n    };\n    /**\n     * Strip the placeholder name from the start of the `messagePart`, if it is found.\n     *\n     * Placeholder marker characters (:) may appear after a substitution that does not provide an\n     * explicit placeholder name. In this case the character must be escaped with a backslash, `\\:`.\n     * We can check for this by looking at the `raw` messagePart, which should still contain the\n     * backslash.\n     *\n     * If the template literal was synthesized then its raw array will only contain empty strings.\n     * This is because TS needs the original source code to find the raw text and in the case of\n     * synthesize AST nodes, there is no source code.\n     *\n     * The workaround is to assume that the template literal did not contain an escaped placeholder\n     * name, and fall back on checking the cooked array instead.\n     *\n     * This should be OK because synthesized nodes (from the Angular template compiler) will always\n     * provide explicit placeholder names and so will never need to escape placeholder name markers.\n     *\n     * @param messagePart The cooked message part to process.\n     * @param rawMessagePart The raw message part to check.\n     * @returns the message part with the placeholder name stripped, if found.\n     */\n    function stripPlaceholderName(messagePart, rawMessagePart) {\n        return (rawMessagePart || messagePart).charAt(0) === PLACEHOLDER_NAME_MARKER ?\n            messagePart.substring(messagePart.indexOf(PLACEHOLDER_NAME_MARKER, 1) + 1) :\n            messagePart;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Attach $localize to the global context, as a side-effect of this module.\n    _global.$localize = $localize;\n\n}));\n//# sourceMappingURL=localize.umd.js.map\n"]}