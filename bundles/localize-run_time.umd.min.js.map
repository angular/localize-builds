{"version":3,"sources":["packages/localize/localize-run_time.umd.js"],"names":["global","factory","exports","module","define","amd","self","ng","localize","run_Time","this","PLACEHOLDER_NAME_MARKER","translate","messageParts","substitutions","message","parseMessage","expressions","replacements","translationKey","i","length","messagePart","expression","raw","charAt","endOfPlaceholderName","indexOf","placeholderName","substring","translation","$localize","TRANSLATIONS","undefined","placeholderNames","map","placeholder","clearTranslations","loadTranslations","translations","Object","keys","forEach","key","parseTranslation","parts","split","push","cooked","rawMessageParts","part","defineProperty","value"],"mappings":";;;;;CAMC,SAAUA,EAAQC,GACI,iBAAZC,SAA0C,oBAAXC,OAAyBF,EAAQC,SACrD,mBAAXE,QAAyBA,OAAOC,IAAMD,OAAO,6BAA8B,CAAC,WAAYH,GACrEA,IAAzBD,EAASA,GAAUM,MAAsBC,GAAKP,EAAOO,IAAM,GAAIP,EAAOO,GAAGC,SAAWR,EAAOO,GAAGC,UAAY,GAAIR,EAAOO,GAAGC,SAASC,SAAW,KAHjJ,CAIEC,KAAM,SAAUR,GAAW,aAKzB,IAAIS,EAA0B,IA8B9B,SAASC,EAAUC,EAAcC,GAC7B,IAAIC,EAkCR,SAASC,EAAaH,EAAcI,GAGhC,IAFA,IAAIC,EAAe,GACfC,EAAiBN,EAAa,GACzBO,EAAI,EAAGA,EAAIP,EAAaQ,OAAQD,IAAK,CAC1C,IAAIE,EAAcT,EAAaO,GAC3BG,EAAaN,EAAYG,EAAI,GAQjC,IAAKP,EAAaW,IAAIJ,IAAME,GAAaG,OAAO,KAAOd,EAAyB,CAC5E,IAAIe,EAAuBJ,EAAYK,QAAQhB,EAAyB,GAExEQ,GAAkB,MADdS,EAAkBN,EAAYO,UAAU,EAAGH,IACJ,IAAMJ,EAAYO,UAAUH,EAAuB,GAC9FR,EAAaU,GAAmBL,MAE/B,CACD,IAAIK,EACJT,GAAkB,MADdS,EAAkB,MAAQR,GACa,IAAME,EACjDJ,EAAaU,GAAmBL,GAGxC,MAAO,CAAEJ,eAAgBA,EAAgBL,cAAeI,GA3D1CF,CAAaH,EAAcC,GACrCgB,EAAcC,UAAUC,aAAajB,EAAQI,gBAKjD,YAJ8Bc,IAAhBH,EAA4B,CAACjB,EAAcC,GAAiB,CACtEgB,EAAYjB,aACZiB,EAAYI,iBAAiBC,IAAI,SAAUC,GAAe,OAAOrB,EAAQD,cAAcsB;;;;;;;;AA6E/FlC,EAAQmC,kBA1FR,SAASA,IACLN,UAAUC,aAAe,IA0F7B9B,EAAQoC,iBA1GR,SAASA,EAAiBC,GAEjBR,UAAUnB,YACXmB,UAAUnB,UAAYA,GAErBmB,UAAUC,eACXD,UAAUC,aAAe,IAE7BQ,OAAOC,KAAKF,GAAcG,QAAQ,SAAUC,GACxCZ,UAAUC,aAAaW,GA8B/B,SAASC,EAAiBzB,GAItB,IAHA,IAAI0B,EAAQ1B,EAAe2B,MAAM,eAC7BjC,EAAe,CAACgC,EAAM,IACtBX,EAAmB,GACdd,EAAI,EAAGA,EAAIyB,EAAMxB,OAAS,EAAGD,GAAK,EACvCc,EAAiBa,KAAKF,EAAMzB,IAC5BP,EAAakC,KAAK,GAAKF,EAAMzB,EAAI,IAErC,IA6CwB4B,EAAQxB,EA7C5ByB,EAAkBpC,EAAasB,IAAI,SAAUe,GAAQ,OAAOA,EAAKzB,OAAO,KAAOd,EAA0B,KAAOuC,EAAOA,IAC3H,MAAO,CAAErC,cA4CemC,EA5CkBnC,EA4CVW,EA5CwByB,EA6CxDT,OAAOW,eAAeH,EAAQ,MAAO,CAAEI,MAAO5B,IACvCwB,GA9CmEd,iBAAkBA,GAvC1DU,CAAiBL,EAAaI,OAmGpEH,OAAOW,eAAejD,EAAS,aAAc,CAAEkD,OAAO","sourcesContent":["/**\n * @license Angular v9.0.0-next.6+3.sha-bb9e612.with-local-changes\n * (c) 2010-2019 Google LLC. https://angular.io/\n * License: MIT\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define('@angular/localize/run_time', ['exports'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.localize = global.ng.localize || {}, global.ng.localize.run_Time = {})));\n}(this, function (exports) { 'use strict';\n\n    /**\n     * The character used to mark the start and end of a placeholder name.\n     */\n    var PLACEHOLDER_NAME_MARKER = ':';\n    /**\n     * Load translations for `$localize`.\n     *\n     * The given `translations` are processed and added to a lookup based on their translation key.\n     * A new translation will overwrite a previous translation if it has the same key.\n     */\n    function loadTranslations(translations) {\n        // Ensure the translate function exists\n        if (!$localize.translate) {\n            $localize.translate = translate;\n        }\n        if (!$localize.TRANSLATIONS) {\n            $localize.TRANSLATIONS = {};\n        }\n        Object.keys(translations).forEach(function (key) {\n            $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);\n        });\n    }\n    /**\n     * Remove all translations for `$localize`.\n     */\n    function clearTranslations() {\n        $localize.TRANSLATIONS = {};\n    }\n    /**\n     * Translate the text of the given message, using the loaded translations.\n     *\n     * This function may reorder (or remove) substitutions as indicated in the matching translation.\n     */\n    function translate(messageParts, substitutions) {\n        var message = parseMessage(messageParts, substitutions);\n        var translation = $localize.TRANSLATIONS[message.translationKey];\n        var result = (translation === undefined ? [messageParts, substitutions] : [\n            translation.messageParts,\n            translation.placeholderNames.map(function (placeholder) { return message.substitutions[placeholder]; })\n        ]);\n        return result;\n    }\n    /////////////\n    // Helpers\n    /**\n     * Parse the `messageParts` and `placeholderNames` out of a translation key.\n     *\n     * @param translationKey the message to be parsed.\n     */\n    function parseTranslation(translationKey) {\n        var parts = translationKey.split(/{\\$([^}]*)}/);\n        var messageParts = [parts[0]];\n        var placeholderNames = [];\n        for (var i = 1; i < parts.length - 1; i += 2) {\n            placeholderNames.push(parts[i]);\n            messageParts.push(\"\" + parts[i + 1]);\n        }\n        var rawMessageParts = messageParts.map(function (part) { return part.charAt(0) === PLACEHOLDER_NAME_MARKER ? '\\\\' + part : part; });\n        return { messageParts: makeTemplateObject(messageParts, rawMessageParts), placeholderNames: placeholderNames };\n    }\n    /**\n     * Process the `messageParts` and `substitutions` that were passed to the `$localize` tag in order\n     * to match it to a translation.\n     *\n     * Specifically this function computes:\n     * * the `translationKey` for looking up an appropriate translation for this message.\n     * * a map of placeholder names to substitutions values.\n     */\n    function parseMessage(messageParts, expressions) {\n        var replacements = {};\n        var translationKey = messageParts[0];\n        for (var i = 1; i < messageParts.length; i++) {\n            var messagePart = messageParts[i];\n            var expression = expressions[i - 1];\n            // There is a problem with synthesizing template literals in TS.\n            // It is not possible to provide raw values for the `messageParts` and TS is not able to compute\n            // them since this requires access to the string in its original (non-existent) source code.\n            // Therefore we fall back on the non-raw version if the raw string is empty.\n            // This should be OK because synthesized nodes only come from the template compiler and they\n            // will always contain placeholder name information.\n            // So there will be no escaped placeholder marker character (`:`) directly after a substitution.\n            if ((messageParts.raw[i] || messagePart).charAt(0) === PLACEHOLDER_NAME_MARKER) {\n                var endOfPlaceholderName = messagePart.indexOf(PLACEHOLDER_NAME_MARKER, 1);\n                var placeholderName = messagePart.substring(1, endOfPlaceholderName);\n                translationKey += \"{$\" + placeholderName + \"}\" + messagePart.substring(endOfPlaceholderName + 1);\n                replacements[placeholderName] = expression;\n            }\n            else {\n                var placeholderName = \"ph_\" + i;\n                translationKey += \"{$\" + placeholderName + \"}\" + messagePart;\n                replacements[placeholderName] = expression;\n            }\n        }\n        return { translationKey: translationKey, substitutions: replacements };\n    }\n    /**\n     * Make an array of `cooked` strings that also holds the `raw` strings in an additional property.\n     *\n     * @param cooked The actual values of the `messagePart` strings.\n     * @param raw The original raw values of the `messagePart` strings, before escape characters are\n     * processed.\n     */\n    function makeTemplateObject(cooked, raw) {\n        Object.defineProperty(cooked, 'raw', { value: raw });\n        return cooked;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    exports.clearTranslations = clearTranslations;\n    exports.loadTranslations = loadTranslations;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=localize-run_time.umd.js.map\n"]}