{"version":3,"file":"localize-init.umd.js","sources":["../../../../../../../packages/localize/src/localize/src/global.ts","../../../../../../../packages/localize/src/localize/src/localize.ts","../../../../../../../packages/localize/src/localize/index.ts","../../../../../../packages/localize/init/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// **********************************************************************************************\n// This code to access the global object is mostly copied from `packages/core/src/util/global.ts`\n\ndeclare global {\n  var WorkerGlobalScope: any;\n}\n\nconst __globalThis = typeof globalThis !== 'undefined' && globalThis;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n// Always use __globalThis if available; this is the spec-defined global variable across all\n// environments.\n// Then fallback to __global first; in Node tests both __global and __window may be defined.\nexport const _global: any = __globalThis || __global || __window || __self;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface LocalizeFn {\n  (messageParts: TemplateStringsArray, ...expressions: readonly any[]): string;\n\n  /**\n   * A function that converts an input \"message with expressions\" into a translated \"message with\n   * expressions\".\n   *\n   * The conversion may be done in place, modifying the array passed to the function, so\n   * don't assume that this has no side-effects.\n   *\n   * The expressions must be passed in since it might be they need to be reordered for\n   * different translations.\n   */\n  translate?: TranslateFn;\n}\n\nexport interface TranslateFn {\n  (messageParts: TemplateStringsArray,\n   expressions: readonly any[]): [TemplateStringsArray, readonly any[]];\n}\n\n/**\n * Tag a template literal string for localization.\n *\n * For example:\n *\n * ```ts\n * $localize `some string to localize`\n * ```\n *\n * **Naming placeholders**\n *\n * If the template literal string contains expressions then you can optionally name the placeholder\n * associated with each expression. Do this by providing the placeholder name wrapped in `:`\n * characters directly after the expression. These placeholder names are stripped out of the\n * rendered localized string.\n *\n * For example, to name the `item.length` expression placeholder `itemCount` you write:\n *\n * ```ts\n * $localize `There are ${item.length}:itemCount: items`;\n * ```\n *\n * If you need to use a `:` character directly an expression you must either provide a name or you\n * can escape the `:` by preceding it with a backslash:\n *\n * For example:\n *\n * ```ts\n * $localize `${label}:label:: ${}`\n * // or\n * $localize `${label}\\: ${}`\n * ```\n *\n * **Processing localized strings:**\n *\n * There are three scenarios:\n *\n * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a transpiler,\n * removing the tag and replacing the template literal string with a translated literal string\n * from a collection of translations provided to the transpilation tool.\n *\n * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and reorders\n * the parts (static strings and expressions) of the template literal string with strings from a\n * collection of translations loaded at run-time.\n *\n * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n * the original template literal string without applying any translations to the parts. This version\n * is used during development or where there is no need to translate the localized template\n * literals.\n *\n * @param messageParts a collection of the static parts of the template string.\n * @param expressions a collection of the values of each placeholder in the template string.\n * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n */\nexport const $localize: LocalizeFn = function(\n    messageParts: TemplateStringsArray, ...expressions: readonly any[]) {\n  if ($localize.translate) {\n    // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n    const translation = $localize.translate(messageParts, expressions);\n    messageParts = translation[0];\n    expressions = translation[1];\n  }\n  let message = stripBlock(messageParts[0], messageParts.raw[0]);\n  for (let i = 1; i < messageParts.length; i++) {\n    message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\n  }\n  return message;\n};\n\nconst BLOCK_MARKER = ':';\n\n/**\n * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\n *\n * If a marker character (:) actually appears in the content at the start of a tagged string or\n * after a substitution expression, where a block has not been provided the character must be\n * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\n * messagePart, which should still contain the backslash.\n *\n * If the template literal was synthesized, rather than appearing in original source code, then its\n * raw array will only contain empty strings. This is because the current TypeScript compiler use\n * the original source code to find the raw text and in the case of synthesized AST nodes, there is\n * no source code to draw upon.\n *\n * The workaround in this function is to assume that the template literal did not contain an escaped\n * placeholder name, and fall back on checking the cooked array instead. This should be OK because\n * synthesized nodes (from the Angular template compiler) will always provide explicit delimited\n * blocks and so will never need to escape placeholder name markers.\n *\n * @param messagePart The cooked message part to process.\n * @param rawMessagePart The raw message part to check.\n * @returns the message part with the placeholder name stripped, if found.\n */\nfunction stripBlock(messagePart: string, rawMessagePart: string) {\n  return (rawMessagePart || messagePart).charAt(0) === BLOCK_MARKER ?\n      messagePart.substring(messagePart.indexOf(BLOCK_MARKER, 1) + 1) :\n      messagePart;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport {_global} from './src/global';\nexport {$localize, LocalizeFn, TranslateFn} from './src/localize';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {$localize, LocalizeFn, _global} from '../src/localize';\n\nexport {LocalizeFn, TranslateFn} from '../src/localize';\n\n// Attach $localize to the global context, as a side-effect of this module.\n_global.$localize = $localize;\n\n// `declare global` allows us to escape the current module and place types on the global namespace\ndeclare global {\n  /**\n   * Tag a template literal string for localization.\n   *\n   * For example:\n   *\n   * ```ts\n   * $localize `some string to localize`\n   * ```\n   *\n   * **Providing meaning, description and id**\n   *\n   * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n   * string by pre-pending it with a colon delimited block of the form:\n   *\n   * ```ts\n   * $localize`:meaning|description@@id:source message text`;\n   *\n   * $localize`:meaning|:source message text`;\n   * $localize`:description:source message text`;\n   * $localize`:@@id:source message text`;\n   * ```\n   *\n   * This format is the same as that used for `i18n` markers in Angular templates. See the\n   * [Angular 18n guide](guide/i18n#template-translations).\n   *\n   * **Naming placeholders**\n   *\n   * If the template literal string contains expressions then you can optionally name the\n   * placeholder\n   * associated with each expression. Do this by providing the placeholder name wrapped in `:`\n   * characters directly after the expression. These placeholder names are stripped out of the\n   * rendered localized string.\n   *\n   * For example, to name the `item.length` expression placeholder `itemCount` you write:\n   *\n   * ```ts\n   * $localize `There are ${item.length}:itemCount: items`;\n   * ```\n   *\n   * **Escaping colon markers**\n   *\n   * If you need to use a `:` character directly at the start of a tagged string that has no\n   * metadata block, or directly after a substitution expression that has no name you must escape\n   * the `:` by preceding it with a backslash:\n   *\n   * For example:\n   *\n   * ```ts\n   * // message has a metadata block so no need to escape colon\n   * $localize `:some description::this message starts with a colon (:)`;\n   * // no metadata block so the colon must be escaped\n   * $localize `\\:this message starts with a colon (:)`;\n   * ```\n   *\n   * ```ts\n   * // named substitution so no need to escape colon\n   * $localize `${label}:label:: ${}`\n   * // anonymous substitution so colon must be escaped\n   * $localize `${label}\\: ${}`\n   * ```\n   *\n   * **Processing localized strings:**\n   *\n   * There are three scenarios:\n   *\n   * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n   * transpiler, removing the tag and replacing the template literal string with a translated\n   * literal string from a collection of translations provided to the transpilation tool.\n   *\n   * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n   * reorders the parts (static strings and expressions) of the template literal string with strings\n   * from a collection of translations loaded at run-time.\n   *\n   * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n   * the original template literal string without applying any translations to the parts. This\n   * version is used during development or where there is no need to translate the localized\n   * template literals.\n   *\n   * @param messageParts a collection of the static parts of the template string.\n   * @param expressions a collection of the values of each placeholder in the template string.\n   * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n   */\n  const $localize: LocalizeFn;\n}\n"],"names":[],"mappings":";;;;;;;;;;;IAAA;;;;;;;IAeA,IAAM,YAAY,GAAG,OAAO,UAAU,KAAK,WAAW,IAAI,UAAU,CAAC;IACrE,IAAM,QAAQ,GAAG,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC;IACzD,IAAM,MAAM,GAAG,OAAO,IAAI,KAAK,WAAW,IAAI,OAAO,iBAAiB,KAAK,WAAW;QAClF,IAAI,YAAY,iBAAiB,IAAI,IAAI,CAAC;IAC9C,IAAM,QAAQ,GAAG,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC;IACzD;IACA;IACA;AACA,IAAO,IAAM,OAAO,GAAQ,YAAY,IAAI,QAAQ,IAAI,QAAQ,IAAI,MAAM,CAAC;;ICvB3E;;;;;;;IA6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDA,IAAO,IAAM,SAAS,GAAe,UACjC,YAAkC;QAAE,qBAA8B;aAA9B,UAA8B,EAA9B,qBAA8B,EAA9B,IAA8B;YAA9B,oCAA8B;;QACpE,IAAI,SAAS,CAAC,SAAS,EAAE;;YAEvB,IAAM,WAAW,GAAG,SAAS,CAAC,SAAS,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;YACnE,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;YAC9B,WAAW,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;SAC9B;QACD,IAAI,OAAO,GAAG,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC5C,OAAO,IAAI,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;SAClF;QACD,OAAO,OAAO,CAAC;IACjB,CAAC,CAAC;IAEF,IAAM,YAAY,GAAG,GAAG,CAAC;IAEzB;;;;;;;;;;;;;;;;;;;;;;IAsBA,SAAS,UAAU,CAAC,WAAmB,EAAE,cAAsB;QAC7D,OAAO,CAAC,cAAc,IAAI,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC,KAAK,YAAY;YAC7D,WAAW,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;YAC/D,WAAW,CAAC;IAClB,CAAC;;IC9HD;;;;;;OAMG;;ICNH;;;;;;;AAOA,IAIA;IACA,OAAO,CAAC,SAAS,GAAG,SAAS,CAAC;;;;"}