{"version":3,"file":"run_time.js","sources":["../run_time/src/translate.ts","../run_time/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {LocalizeFn} from '@angular/localize';\n\n/**\n * We augment the `$localize` object to also store the translations.\n *\n * Note that because the TRANSLATIONS are attached to a global object, they will be shared between\n * all applications that are running in a single page of the browser.\n */\ndeclare const $localize: LocalizeFn&{TRANSLATIONS: {[key: string]: ParsedTranslation}};\n\n/**\n * A map of translations.\n *\n * The key is the original translation message, the value is the translated message.\n *\n * The format of these translation message strings uses `{$marker}` to indicate a placeholder.\n */\nexport interface Translations { [translationKey: string]: string; }\n\n/**\n * A translation message that has been processed to extract the message parts and placeholders.\n *\n * This is the format used by the runtime inlining to translate messages.\n */\nexport interface ParsedTranslation {\n  messageParts: TemplateStringsArray;\n  placeholderNames: string[];\n}\n\n/**\n * A localized message that has been processed to compute the translation key for looking up the\n * appropriate translation.\n */\nexport interface ParsedMessage {\n  translationKey: string;\n  substitutions: {[placeholderName: string]: any};\n}\n\n/**\n * The character used to mark the start and end of a placeholder name.\n */\nconst PLACEHOLDER_NAME_MARKER = ':';\n\n/**\n * Load translations for `$localize`.\n *\n * The given `translations` are processed and added to a lookup based on their translation key.\n * A new translation will overwrite a previous translation if it has the same key.\n */\nexport function loadTranslations(translations: Translations) {\n  // Ensure the translate function exists\n  if (!$localize.translate) {\n    $localize.translate = translate;\n  }\n  if (!$localize.TRANSLATIONS) {\n    $localize.TRANSLATIONS = {};\n  }\n  Object.keys(translations).forEach(key => {\n    $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);\n  });\n}\n\n/**\n * Remove all translations for `$localize`.\n */\nexport function clearTranslations() {\n  $localize.TRANSLATIONS = {};\n}\n\n/**\n * Translate the text of the given message, using the loaded translations.\n *\n * This function may reorder (or remove) substitutions as indicated in the matching translation.\n */\nexport function translate(messageParts: TemplateStringsArray, substitutions: readonly any[]):\n    [TemplateStringsArray, readonly any[]] {\n  const message = parseMessage(messageParts, substitutions);\n  const translation = $localize.TRANSLATIONS[message.translationKey];\n  const result: [TemplateStringsArray, readonly any[]] =\n      (translation === undefined ? [messageParts, substitutions] : [\n        translation.messageParts,\n        translation.placeholderNames.map(placeholder => message.substitutions[placeholder])\n      ]);\n  return result;\n}\n\n/////////////\n// Helpers\n\n/**\n * Parse the `messageParts` and `placeholderNames` out of a translation key.\n *\n * @param translationKey the message to be parsed.\n */\nexport function parseTranslation(translationKey: string): ParsedTranslation {\n  const parts = translationKey.split(/{\\$([^}]*)}/);\n  const messageParts = [parts[0]];\n  const placeholderNames: string[] = [];\n  for (let i = 1; i < parts.length - 1; i += 2) {\n    placeholderNames.push(parts[i]);\n    messageParts.push(`${parts[i + 1]}`);\n  }\n  const rawMessageParts =\n      messageParts.map(part => part.charAt(0) === PLACEHOLDER_NAME_MARKER ? '\\\\' + part : part);\n  return {messageParts: makeTemplateObject(messageParts, rawMessageParts), placeholderNames};\n}\n\n/**\n * Process the `messageParts` and `substitutions` that were passed to the `$localize` tag in order\n * to match it to a translation.\n *\n * Specifically this function computes:\n * * the `translationKey` for looking up an appropriate translation for this message.\n * * a map of placeholder names to substitutions values.\n */\nexport function parseMessage(\n    messageParts: TemplateStringsArray, expressions: readonly any[]): ParsedMessage {\n  const replacements: {[placeholderName: string]: any} = {};\n  let translationKey = messageParts[0];\n  for (let i = 1; i < messageParts.length; i++) {\n    const messagePart = messageParts[i];\n    const expression = expressions[i - 1];\n    // There is a problem with synthesizing template literals in TS.\n    // It is not possible to provide raw values for the `messageParts` and TS is not able to compute\n    // them since this requires access to the string in its original (non-existent) source code.\n    // Therefore we fall back on the non-raw version if the raw string is empty.\n    // This should be OK because synthesized nodes only come from the template compiler and they\n    // will always contain placeholder name information.\n    // So there will be no escaped placeholder marker character (`:`) directly after a substitution.\n    if ((messageParts.raw[i] || messagePart).charAt(0) === PLACEHOLDER_NAME_MARKER) {\n      const endOfPlaceholderName = messagePart.indexOf(PLACEHOLDER_NAME_MARKER, 1);\n      const placeholderName = messagePart.substring(1, endOfPlaceholderName);\n      translationKey += `{$${placeholderName}}${messagePart.substring(endOfPlaceholderName + 1)}`;\n      replacements[placeholderName] = expression;\n    } else {\n      const placeholderName = `ph_${i}`;\n      translationKey += `{$${placeholderName}}${messagePart}`;\n      replacements[placeholderName] = expression;\n    }\n  }\n  return {translationKey, substitutions: replacements};\n}\n\n/**\n * Make an array of `cooked` strings that also holds the `raw` strings in an additional property.\n *\n * @param cooked The actual values of the `messagePart` strings.\n * @param raw The original raw values of the `messagePart` strings, before escape characters are\n * processed.\n */\nfunction makeTemplateObject(cooked: string[], raw: string[]): TemplateStringsArray {\n  Object.defineProperty(cooked, 'raw', {value: raw});\n  return cooked as any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport {clearTranslations, loadTranslations} from './src/translate';\n"],"names":[],"mappings":"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"}