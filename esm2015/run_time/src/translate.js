/**
 * The character used to mark the start and end of a placeholder name.
 */
const PLACEHOLDER_NAME_MARKER = ':';
/**
 * Load translations for `$localize`.
 *
 * The given `translations` are processed and added to a lookup based on their translation key.
 * A new translation will overwrite a previous translation if it has the same key.
 */
export function loadTranslations(translations) {
    // Ensure the translate function exists
    if (!$localize.translate) {
        $localize.translate = translate;
    }
    if (!$localize.TRANSLATIONS) {
        $localize.TRANSLATIONS = {};
    }
    Object.keys(translations).forEach(key => {
        $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);
    });
}
/**
 * Remove all translations for `$localize`.
 */
export function clearTranslations() {
    $localize.TRANSLATIONS = {};
}
/**
 * Translate the text of the given message, using the loaded translations.
 *
 * This function may reorder (or remove) substitutions as indicated in the matching translation.
 */
export function translate(messageParts, substitutions) {
    const message = parseMessage(messageParts, substitutions);
    const translation = $localize.TRANSLATIONS[message.translationKey];
    const result = (translation === undefined ? [messageParts, substitutions] : [
        translation.messageParts,
        translation.placeholderNames.map(placeholder => message.substitutions[placeholder])
    ]);
    return result;
}
/////////////
// Helpers
/**
 * Parse the `messageParts` and `placeholderNames` out of a translation key.
 *
 * @param translationKey the message to be parsed.
 */
export function parseTranslation(translationKey) {
    const parts = translationKey.split(/{\$([^}]*)}/);
    const messageParts = [parts[0]];
    const placeholderNames = [];
    for (let i = 1; i < parts.length - 1; i += 2) {
        placeholderNames.push(parts[i]);
        messageParts.push(`${parts[i + 1]}`);
    }
    const rawMessageParts = messageParts.map(part => part.charAt(0) === PLACEHOLDER_NAME_MARKER ? '\\' + part : part);
    return { messageParts: makeTemplateObject(messageParts, rawMessageParts), placeholderNames };
}
/**
 * Process the `messageParts` and `substitutions` that were passed to the `$localize` tag in order
 * to match it to a translation.
 *
 * Specifically this function computes:
 * * the `translationKey` for looking up an appropriate translation for this message.
 * * a map of placeholder names to substitutions values.
 */
export function parseMessage(messageParts, expressions) {
    const replacements = {};
    let translationKey = messageParts[0];
    for (let i = 1; i < messageParts.length; i++) {
        const messagePart = messageParts[i];
        const expression = expressions[i - 1];
        // There is a problem with synthesizing template literals in TS.
        // It is not possible to provide raw values for the `messageParts` and TS is not able to compute
        // them since this requires access to the string in its original (non-existent) source code.
        // Therefore we fall back on the non-raw version if the raw string is empty.
        // This should be OK because synthesized nodes only come from the template compiler and they
        // will always contain placeholder name information.
        // So there will be no escaped placeholder marker character (`:`) directly after a substitution.
        if ((messageParts.raw[i] || messagePart).charAt(0) === PLACEHOLDER_NAME_MARKER) {
            const endOfPlaceholderName = messagePart.indexOf(PLACEHOLDER_NAME_MARKER, 1);
            const placeholderName = messagePart.substring(1, endOfPlaceholderName);
            translationKey += `{$${placeholderName}}${messagePart.substring(endOfPlaceholderName + 1)}`;
            replacements[placeholderName] = expression;
        }
        else {
            const placeholderName = `ph_${i}`;
            translationKey += `{$${placeholderName}}${messagePart}`;
            replacements[placeholderName] = expression;
        }
    }
    return { translationKey, substitutions: replacements };
}
/**
 * Make an array of `cooked` strings that also holds the `raw` strings in an additional property.
 *
 * @param cooked The actual values of the `messagePart` strings.
 * @param raw The original raw values of the `messagePart` strings, before escape characters are
 * processed.
 */
function makeTemplateObject(cooked, raw) {
    Object.defineProperty(cooked, 'raw', { value: raw });
    return cooked;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvbG9jYWxpemUvcnVuX3RpbWUvc3JjL3RyYW5zbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE2Q0E7O0dBRUc7QUFDSCxNQUFNLHVCQUF1QixHQUFHLEdBQUcsQ0FBQztBQUVwQzs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxZQUEwQjtJQUN6RCx1Q0FBdUM7SUFDdkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUU7UUFDeEIsU0FBUyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7S0FDakM7SUFDRCxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRTtRQUMzQixTQUFTLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztLQUM3QjtJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3RDLFNBQVMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDcEUsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCO0lBQy9CLFNBQVMsQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0FBQzlCLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FBQyxZQUFrQyxFQUFFLGFBQTZCO0lBRXpGLE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQyxZQUFZLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDMUQsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDbkUsTUFBTSxNQUFNLEdBQ1IsQ0FBQyxXQUFXLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0QsV0FBVyxDQUFDLFlBQVk7UUFDeEIsV0FBVyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDcEYsQ0FBQyxDQUFDO0lBQ1AsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUVELGFBQWE7QUFDYixVQUFVO0FBRVY7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxjQUFzQjtJQUNyRCxNQUFNLEtBQUssR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ2xELE1BQU0sWUFBWSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEMsTUFBTSxnQkFBZ0IsR0FBYSxFQUFFLENBQUM7SUFDdEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDNUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUN0QztJQUNELE1BQU0sZUFBZSxHQUNqQixZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUYsT0FBTyxFQUFDLFlBQVksRUFBRSxrQkFBa0IsQ0FBQyxZQUFZLEVBQUUsZUFBZSxDQUFDLEVBQUUsZ0JBQWdCLEVBQUMsQ0FBQztBQUM3RixDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxZQUFZLENBQ3hCLFlBQWtDLEVBQUUsV0FBMkI7SUFDakUsTUFBTSxZQUFZLEdBQXFDLEVBQUUsQ0FBQztJQUMxRCxJQUFJLGNBQWMsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDNUMsTUFBTSxXQUFXLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdEMsZ0VBQWdFO1FBQ2hFLGdHQUFnRztRQUNoRyw0RkFBNEY7UUFDNUYsNEVBQTRFO1FBQzVFLDRGQUE0RjtRQUM1RixvREFBb0Q7UUFDcEQsZ0dBQWdHO1FBQ2hHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyx1QkFBdUIsRUFBRTtZQUM5RSxNQUFNLG9CQUFvQixHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDN0UsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztZQUN2RSxjQUFjLElBQUksS0FBSyxlQUFlLElBQUksV0FBVyxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQzVGLFlBQVksQ0FBQyxlQUFlLENBQUMsR0FBRyxVQUFVLENBQUM7U0FDNUM7YUFBTTtZQUNMLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUM7WUFDbEMsY0FBYyxJQUFJLEtBQUssZUFBZSxJQUFJLFdBQVcsRUFBRSxDQUFDO1lBQ3hELFlBQVksQ0FBQyxlQUFlLENBQUMsR0FBRyxVQUFVLENBQUM7U0FDNUM7S0FDRjtJQUNELE9BQU8sRUFBQyxjQUFjLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBQyxDQUFDO0FBQ3ZELENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFTLGtCQUFrQixDQUFDLE1BQWdCLEVBQUUsR0FBYTtJQUN6RCxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBQyxLQUFLLEVBQUUsR0FBRyxFQUFDLENBQUMsQ0FBQztJQUNuRCxPQUFPLE1BQWEsQ0FBQztBQUN2QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHtMb2NhbGl6ZUZufSBmcm9tICdAYW5ndWxhci9sb2NhbGl6ZSc7XG5cbi8qKlxuICogV2UgYXVnbWVudCB0aGUgYCRsb2NhbGl6ZWAgb2JqZWN0IHRvIGFsc28gc3RvcmUgdGhlIHRyYW5zbGF0aW9ucy5cbiAqXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB0aGUgVFJBTlNMQVRJT05TIGFyZSBhdHRhY2hlZCB0byBhIGdsb2JhbCBvYmplY3QsIHRoZXkgd2lsbCBiZSBzaGFyZWQgYmV0d2VlblxuICogYWxsIGFwcGxpY2F0aW9ucyB0aGF0IGFyZSBydW5uaW5nIGluIGEgc2luZ2xlIHBhZ2Ugb2YgdGhlIGJyb3dzZXIuXG4gKi9cbmRlY2xhcmUgY29uc3QgJGxvY2FsaXplOiBMb2NhbGl6ZUZuJntUUkFOU0xBVElPTlM6IHtba2V5OiBzdHJpbmddOiBQYXJzZWRUcmFuc2xhdGlvbn19O1xuXG4vKipcbiAqIEEgbWFwIG9mIHRyYW5zbGF0aW9ucy5cbiAqXG4gKiBUaGUga2V5IGlzIHRoZSBvcmlnaW5hbCB0cmFuc2xhdGlvbiBtZXNzYWdlLCB0aGUgdmFsdWUgaXMgdGhlIHRyYW5zbGF0ZWQgbWVzc2FnZS5cbiAqXG4gKiBUaGUgZm9ybWF0IG9mIHRoZXNlIHRyYW5zbGF0aW9uIG1lc3NhZ2Ugc3RyaW5ncyB1c2VzIGB7JG1hcmtlcn1gIHRvIGluZGljYXRlIGEgcGxhY2Vob2xkZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNsYXRpb25zIHsgW3RyYW5zbGF0aW9uS2V5OiBzdHJpbmddOiBzdHJpbmc7IH1cblxuLyoqXG4gKiBBIHRyYW5zbGF0aW9uIG1lc3NhZ2UgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWQgdG8gZXh0cmFjdCB0aGUgbWVzc2FnZSBwYXJ0cyBhbmQgcGxhY2Vob2xkZXJzLlxuICpcbiAqIFRoaXMgaXMgdGhlIGZvcm1hdCB1c2VkIGJ5IHRoZSBydW50aW1lIGlubGluaW5nIHRvIHRyYW5zbGF0ZSBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRUcmFuc2xhdGlvbiB7XG4gIG1lc3NhZ2VQYXJ0czogVGVtcGxhdGVTdHJpbmdzQXJyYXk7XG4gIHBsYWNlaG9sZGVyTmFtZXM6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEEgbG9jYWxpemVkIG1lc3NhZ2UgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWQgdG8gY29tcHV0ZSB0aGUgdHJhbnNsYXRpb24ga2V5IGZvciBsb29raW5nIHVwIHRoZVxuICogYXBwcm9wcmlhdGUgdHJhbnNsYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkTWVzc2FnZSB7XG4gIHRyYW5zbGF0aW9uS2V5OiBzdHJpbmc7XG4gIHN1YnN0aXR1dGlvbnM6IHtbcGxhY2Vob2xkZXJOYW1lOiBzdHJpbmddOiBhbnl9O1xufVxuXG4vKipcbiAqIFRoZSBjaGFyYWN0ZXIgdXNlZCB0byBtYXJrIHRoZSBzdGFydCBhbmQgZW5kIG9mIGEgcGxhY2Vob2xkZXIgbmFtZS5cbiAqL1xuY29uc3QgUExBQ0VIT0xERVJfTkFNRV9NQVJLRVIgPSAnOic7XG5cbi8qKlxuICogTG9hZCB0cmFuc2xhdGlvbnMgZm9yIGAkbG9jYWxpemVgLlxuICpcbiAqIFRoZSBnaXZlbiBgdHJhbnNsYXRpb25zYCBhcmUgcHJvY2Vzc2VkIGFuZCBhZGRlZCB0byBhIGxvb2t1cCBiYXNlZCBvbiB0aGVpciB0cmFuc2xhdGlvbiBrZXkuXG4gKiBBIG5ldyB0cmFuc2xhdGlvbiB3aWxsIG92ZXJ3cml0ZSBhIHByZXZpb3VzIHRyYW5zbGF0aW9uIGlmIGl0IGhhcyB0aGUgc2FtZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkVHJhbnNsYXRpb25zKHRyYW5zbGF0aW9uczogVHJhbnNsYXRpb25zKSB7XG4gIC8vIEVuc3VyZSB0aGUgdHJhbnNsYXRlIGZ1bmN0aW9uIGV4aXN0c1xuICBpZiAoISRsb2NhbGl6ZS50cmFuc2xhdGUpIHtcbiAgICAkbG9jYWxpemUudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuICB9XG4gIGlmICghJGxvY2FsaXplLlRSQU5TTEFUSU9OUykge1xuICAgICRsb2NhbGl6ZS5UUkFOU0xBVElPTlMgPSB7fTtcbiAgfVxuICBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAkbG9jYWxpemUuVFJBTlNMQVRJT05TW2tleV0gPSBwYXJzZVRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uc1trZXldKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0cmFuc2xhdGlvbnMgZm9yIGAkbG9jYWxpemVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJUcmFuc2xhdGlvbnMoKSB7XG4gICRsb2NhbGl6ZS5UUkFOU0xBVElPTlMgPSB7fTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgdGhlIHRleHQgb2YgdGhlIGdpdmVuIG1lc3NhZ2UsIHVzaW5nIHRoZSBsb2FkZWQgdHJhbnNsYXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF5IHJlb3JkZXIgKG9yIHJlbW92ZSkgc3Vic3RpdHV0aW9ucyBhcyBpbmRpY2F0ZWQgaW4gdGhlIG1hdGNoaW5nIHRyYW5zbGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG1lc3NhZ2VQYXJ0czogVGVtcGxhdGVTdHJpbmdzQXJyYXksIHN1YnN0aXR1dGlvbnM6IHJlYWRvbmx5IGFueVtdKTpcbiAgICBbVGVtcGxhdGVTdHJpbmdzQXJyYXksIHJlYWRvbmx5IGFueVtdXSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2UobWVzc2FnZVBhcnRzLCBzdWJzdGl0dXRpb25zKTtcbiAgY29uc3QgdHJhbnNsYXRpb24gPSAkbG9jYWxpemUuVFJBTlNMQVRJT05TW21lc3NhZ2UudHJhbnNsYXRpb25LZXldO1xuICBjb25zdCByZXN1bHQ6IFtUZW1wbGF0ZVN0cmluZ3NBcnJheSwgcmVhZG9ubHkgYW55W11dID1cbiAgICAgICh0cmFuc2xhdGlvbiA9PT0gdW5kZWZpbmVkID8gW21lc3NhZ2VQYXJ0cywgc3Vic3RpdHV0aW9uc10gOiBbXG4gICAgICAgIHRyYW5zbGF0aW9uLm1lc3NhZ2VQYXJ0cyxcbiAgICAgICAgdHJhbnNsYXRpb24ucGxhY2Vob2xkZXJOYW1lcy5tYXAocGxhY2Vob2xkZXIgPT4gbWVzc2FnZS5zdWJzdGl0dXRpb25zW3BsYWNlaG9sZGVyXSlcbiAgICAgIF0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXJzXG5cbi8qKlxuICogUGFyc2UgdGhlIGBtZXNzYWdlUGFydHNgIGFuZCBgcGxhY2Vob2xkZXJOYW1lc2Agb3V0IG9mIGEgdHJhbnNsYXRpb24ga2V5LlxuICpcbiAqIEBwYXJhbSB0cmFuc2xhdGlvbktleSB0aGUgbWVzc2FnZSB0byBiZSBwYXJzZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uS2V5OiBzdHJpbmcpOiBQYXJzZWRUcmFuc2xhdGlvbiB7XG4gIGNvbnN0IHBhcnRzID0gdHJhbnNsYXRpb25LZXkuc3BsaXQoL3tcXCQoW159XSopfS8pO1xuICBjb25zdCBtZXNzYWdlUGFydHMgPSBbcGFydHNbMF1dO1xuICBjb25zdCBwbGFjZWhvbGRlck5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHBsYWNlaG9sZGVyTmFtZXMucHVzaChwYXJ0c1tpXSk7XG4gICAgbWVzc2FnZVBhcnRzLnB1c2goYCR7cGFydHNbaSArIDFdfWApO1xuICB9XG4gIGNvbnN0IHJhd01lc3NhZ2VQYXJ0cyA9XG4gICAgICBtZXNzYWdlUGFydHMubWFwKHBhcnQgPT4gcGFydC5jaGFyQXQoMCkgPT09IFBMQUNFSE9MREVSX05BTUVfTUFSS0VSID8gJ1xcXFwnICsgcGFydCA6IHBhcnQpO1xuICByZXR1cm4ge21lc3NhZ2VQYXJ0czogbWFrZVRlbXBsYXRlT2JqZWN0KG1lc3NhZ2VQYXJ0cywgcmF3TWVzc2FnZVBhcnRzKSwgcGxhY2Vob2xkZXJOYW1lc307XG59XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgYG1lc3NhZ2VQYXJ0c2AgYW5kIGBzdWJzdGl0dXRpb25zYCB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBgJGxvY2FsaXplYCB0YWcgaW4gb3JkZXJcbiAqIHRvIG1hdGNoIGl0IHRvIGEgdHJhbnNsYXRpb24uXG4gKlxuICogU3BlY2lmaWNhbGx5IHRoaXMgZnVuY3Rpb24gY29tcHV0ZXM6XG4gKiAqIHRoZSBgdHJhbnNsYXRpb25LZXlgIGZvciBsb29raW5nIHVwIGFuIGFwcHJvcHJpYXRlIHRyYW5zbGF0aW9uIGZvciB0aGlzIG1lc3NhZ2UuXG4gKiAqIGEgbWFwIG9mIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHN1YnN0aXR1dGlvbnMgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNZXNzYWdlKFxuICAgIG1lc3NhZ2VQYXJ0czogVGVtcGxhdGVTdHJpbmdzQXJyYXksIGV4cHJlc3Npb25zOiByZWFkb25seSBhbnlbXSk6IFBhcnNlZE1lc3NhZ2Uge1xuICBjb25zdCByZXBsYWNlbWVudHM6IHtbcGxhY2Vob2xkZXJOYW1lOiBzdHJpbmddOiBhbnl9ID0ge307XG4gIGxldCB0cmFuc2xhdGlvbktleSA9IG1lc3NhZ2VQYXJ0c1swXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBtZXNzYWdlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXNzYWdlUGFydCA9IG1lc3NhZ2VQYXJ0c1tpXTtcbiAgICBjb25zdCBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaSAtIDFdO1xuICAgIC8vIFRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHN5bnRoZXNpemluZyB0ZW1wbGF0ZSBsaXRlcmFscyBpbiBUUy5cbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gcHJvdmlkZSByYXcgdmFsdWVzIGZvciB0aGUgYG1lc3NhZ2VQYXJ0c2AgYW5kIFRTIGlzIG5vdCBhYmxlIHRvIGNvbXB1dGVcbiAgICAvLyB0aGVtIHNpbmNlIHRoaXMgcmVxdWlyZXMgYWNjZXNzIHRvIHRoZSBzdHJpbmcgaW4gaXRzIG9yaWdpbmFsIChub24tZXhpc3RlbnQpIHNvdXJjZSBjb2RlLlxuICAgIC8vIFRoZXJlZm9yZSB3ZSBmYWxsIGJhY2sgb24gdGhlIG5vbi1yYXcgdmVyc2lvbiBpZiB0aGUgcmF3IHN0cmluZyBpcyBlbXB0eS5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBPSyBiZWNhdXNlIHN5bnRoZXNpemVkIG5vZGVzIG9ubHkgY29tZSBmcm9tIHRoZSB0ZW1wbGF0ZSBjb21waWxlciBhbmQgdGhleVxuICAgIC8vIHdpbGwgYWx3YXlzIGNvbnRhaW4gcGxhY2Vob2xkZXIgbmFtZSBpbmZvcm1hdGlvbi5cbiAgICAvLyBTbyB0aGVyZSB3aWxsIGJlIG5vIGVzY2FwZWQgcGxhY2Vob2xkZXIgbWFya2VyIGNoYXJhY3RlciAoYDpgKSBkaXJlY3RseSBhZnRlciBhIHN1YnN0aXR1dGlvbi5cbiAgICBpZiAoKG1lc3NhZ2VQYXJ0cy5yYXdbaV0gfHwgbWVzc2FnZVBhcnQpLmNoYXJBdCgwKSA9PT0gUExBQ0VIT0xERVJfTkFNRV9NQVJLRVIpIHtcbiAgICAgIGNvbnN0IGVuZE9mUGxhY2Vob2xkZXJOYW1lID0gbWVzc2FnZVBhcnQuaW5kZXhPZihQTEFDRUhPTERFUl9OQU1FX01BUktFUiwgMSk7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlck5hbWUgPSBtZXNzYWdlUGFydC5zdWJzdHJpbmcoMSwgZW5kT2ZQbGFjZWhvbGRlck5hbWUpO1xuICAgICAgdHJhbnNsYXRpb25LZXkgKz0gYHskJHtwbGFjZWhvbGRlck5hbWV9fSR7bWVzc2FnZVBhcnQuc3Vic3RyaW5nKGVuZE9mUGxhY2Vob2xkZXJOYW1lICsgMSl9YDtcbiAgICAgIHJlcGxhY2VtZW50c1twbGFjZWhvbGRlck5hbWVdID0gZXhwcmVzc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXJOYW1lID0gYHBoXyR7aX1gO1xuICAgICAgdHJhbnNsYXRpb25LZXkgKz0gYHskJHtwbGFjZWhvbGRlck5hbWV9fSR7bWVzc2FnZVBhcnR9YDtcbiAgICAgIHJlcGxhY2VtZW50c1twbGFjZWhvbGRlck5hbWVdID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHt0cmFuc2xhdGlvbktleSwgc3Vic3RpdHV0aW9uczogcmVwbGFjZW1lbnRzfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIGFycmF5IG9mIGBjb29rZWRgIHN0cmluZ3MgdGhhdCBhbHNvIGhvbGRzIHRoZSBgcmF3YCBzdHJpbmdzIGluIGFuIGFkZGl0aW9uYWwgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIGNvb2tlZCBUaGUgYWN0dWFsIHZhbHVlcyBvZiB0aGUgYG1lc3NhZ2VQYXJ0YCBzdHJpbmdzLlxuICogQHBhcmFtIHJhdyBUaGUgb3JpZ2luYWwgcmF3IHZhbHVlcyBvZiB0aGUgYG1lc3NhZ2VQYXJ0YCBzdHJpbmdzLCBiZWZvcmUgZXNjYXBlIGNoYXJhY3RlcnMgYXJlXG4gKiBwcm9jZXNzZWQuXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQ6IHN0cmluZ1tdLCByYXc6IHN0cmluZ1tdKTogVGVtcGxhdGVTdHJpbmdzQXJyYXkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCAncmF3Jywge3ZhbHVlOiByYXd9KTtcbiAgcmV0dXJuIGNvb2tlZCBhcyBhbnk7XG59XG4iXX0=