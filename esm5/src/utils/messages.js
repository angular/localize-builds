/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { PLACEHOLDER_NAME_MARKER } from './constants';
/**
 * Parse a `$localize` tagged string into a structure that can be used for translation.
 *
 * See `ParsedMessage` for an example.
 */
export function parseMessage(messageParts, expressions) {
    var replacements = {};
    var translationKey = messageParts[0];
    for (var i = 1; i < messageParts.length; i++) {
        var messagePart = messageParts[i];
        var expression = expressions[i - 1];
        // There is a problem with synthesizing template literals in TS.
        // It is not possible to provide raw values for the `messageParts` and TS is not able to compute
        // them since this requires access to the string in its original (non-existent) source code.
        // Therefore we fall back on the non-raw version if the raw string is empty.
        // This should be OK because synthesized nodes only come from the template compiler and they
        // will always contain placeholder name information.
        // So there will be no escaped placeholder marker character (`:`) directly after a substitution.
        if ((messageParts.raw[i] || messagePart).charAt(0) === PLACEHOLDER_NAME_MARKER) {
            var endOfPlaceholderName = messagePart.indexOf(PLACEHOLDER_NAME_MARKER, 1);
            var placeholderName = messagePart.substring(1, endOfPlaceholderName);
            translationKey += "{$" + placeholderName + "}" + messagePart.substring(endOfPlaceholderName + 1);
            replacements[placeholderName] = expression;
        }
        else {
            var placeholderName = "ph_" + i;
            translationKey += "{$" + placeholderName + "}" + messagePart;
            replacements[placeholderName] = expression;
        }
    }
    return { translationKey: translationKey, substitutions: replacements };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVzc2FnZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9sb2NhbGl6ZS9zcmMvdXRpbHMvbWVzc2FnZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBQ0gsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sYUFBYSxDQUFDO0FBMENwRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FDeEIsWUFBa0MsRUFBRSxXQUEyQjtJQUNqRSxJQUFNLFlBQVksR0FBcUMsRUFBRSxDQUFDO0lBQzFELElBQUksY0FBYyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUM1QyxJQUFNLFdBQVcsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEMsSUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN0QyxnRUFBZ0U7UUFDaEUsZ0dBQWdHO1FBQ2hHLDRGQUE0RjtRQUM1Riw0RUFBNEU7UUFDNUUsNEZBQTRGO1FBQzVGLG9EQUFvRDtRQUNwRCxnR0FBZ0c7UUFDaEcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLHVCQUF1QixFQUFFO1lBQzlFLElBQU0sb0JBQW9CLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM3RSxJQUFNLGVBQWUsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1lBQ3ZFLGNBQWMsSUFBSSxPQUFLLGVBQWUsU0FBSSxXQUFXLENBQUMsU0FBUyxDQUFDLG9CQUFvQixHQUFHLENBQUMsQ0FBRyxDQUFDO1lBQzVGLFlBQVksQ0FBQyxlQUFlLENBQUMsR0FBRyxVQUFVLENBQUM7U0FDNUM7YUFBTTtZQUNMLElBQU0sZUFBZSxHQUFHLFFBQU0sQ0FBRyxDQUFDO1lBQ2xDLGNBQWMsSUFBSSxPQUFLLGVBQWUsU0FBSSxXQUFhLENBQUM7WUFDeEQsWUFBWSxDQUFDLGVBQWUsQ0FBQyxHQUFHLFVBQVUsQ0FBQztTQUM1QztLQUNGO0lBQ0QsT0FBTyxFQUFDLGNBQWMsZ0JBQUEsRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFDLENBQUM7QUFDdkQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7UExBQ0VIT0xERVJfTkFNRV9NQVJLRVJ9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7VHJhbnNsYXRpb25LZXl9IGZyb20gJy4vdHJhbnNsYXRpb25zJztcblxuLyoqXG4gKiBBIHN0cmluZyBjb250YWluaW5nIGEgdHJhbnNsYXRpb24gc291cmNlIG1lc3NhZ2UuXG4gKlxuICogSS5FLiB0aGUgbWVzc2FnZSB0aGF0IGluZGljYXRlcyB3aGF0IHdpbGwgYmUgdHJhbnNsYXRlZCBmcm9tLlxuICpcbiAqIFVzZXMgYHskcGxhY2Vob2xkZXItbmFtZX1gIHRvIGluZGljYXRlIGEgcGxhY2Vob2xkZXIuXG4gKi9cbmV4cG9ydCB0eXBlIFNvdXJjZU1lc3NhZ2UgPSBzdHJpbmc7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gcGFyc2VkIGZyb20gYSBgJGxvY2FsaXplYCB0YWdnZWQgc3RyaW5nIHRoYXQgaXMgdXNlZCB0byB0cmFuc2xhdGUgaXQuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiBjb25zdCBuYW1lID0gJ0pvIEJsb2dncyc7XG4gKiAkbG9jYWxpemVgSGVsbG8gJHtuYW1lfTp0aXRsZSFgO1xuICogYGBgXG4gKlxuICogTWF5IGJlIHBhcnNlZCBpbnRvOlxuICpcbiAqIGBgYFxuICoge1xuICogICB0cmFuc2xhdGlvbktleTogJ0hlbGxvIHskdGl0bGV9IScsXG4gKiAgIHN1YnN0aXR1dGlvbnM6IHsgdGl0bGU6ICdKbyBCbG9nZ3MnIH0sXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRNZXNzYWdlIHtcbiAgLyoqXG4gICAqIFRoZSBrZXkgdXNlZCB0byBsb29rIHVwIHRoZSBhcHByb3ByaWF0ZSB0cmFuc2xhdGlvbiB0YXJnZXQuXG4gICAqL1xuICB0cmFuc2xhdGlvbktleTogVHJhbnNsYXRpb25LZXk7XG4gIC8qKlxuICAgKiBBIG1hcHBpbmcgb2YgcGxhY2Vob2xkZXIgbmFtZXMgdG8gc3Vic3RpdHV0aW9uIHZhbHVlcy5cbiAgICovXG4gIHN1YnN0aXR1dGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbi8qKlxuICogUGFyc2UgYSBgJGxvY2FsaXplYCB0YWdnZWQgc3RyaW5nIGludG8gYSBzdHJ1Y3R1cmUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdHJhbnNsYXRpb24uXG4gKlxuICogU2VlIGBQYXJzZWRNZXNzYWdlYCBmb3IgYW4gZXhhbXBsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWVzc2FnZShcbiAgICBtZXNzYWdlUGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCBleHByZXNzaW9uczogcmVhZG9ubHkgYW55W10pOiBQYXJzZWRNZXNzYWdlIHtcbiAgY29uc3QgcmVwbGFjZW1lbnRzOiB7W3BsYWNlaG9sZGVyTmFtZTogc3RyaW5nXTogYW55fSA9IHt9O1xuICBsZXQgdHJhbnNsYXRpb25LZXkgPSBtZXNzYWdlUGFydHNbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWVzc2FnZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWVzc2FnZVBhcnQgPSBtZXNzYWdlUGFydHNbaV07XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zW2kgLSAxXTtcbiAgICAvLyBUaGVyZSBpcyBhIHByb2JsZW0gd2l0aCBzeW50aGVzaXppbmcgdGVtcGxhdGUgbGl0ZXJhbHMgaW4gVFMuXG4gICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIHByb3ZpZGUgcmF3IHZhbHVlcyBmb3IgdGhlIGBtZXNzYWdlUGFydHNgIGFuZCBUUyBpcyBub3QgYWJsZSB0byBjb21wdXRlXG4gICAgLy8gdGhlbSBzaW5jZSB0aGlzIHJlcXVpcmVzIGFjY2VzcyB0byB0aGUgc3RyaW5nIGluIGl0cyBvcmlnaW5hbCAobm9uLWV4aXN0ZW50KSBzb3VyY2UgY29kZS5cbiAgICAvLyBUaGVyZWZvcmUgd2UgZmFsbCBiYWNrIG9uIHRoZSBub24tcmF3IHZlcnNpb24gaWYgdGhlIHJhdyBzdHJpbmcgaXMgZW1wdHkuXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgT0sgYmVjYXVzZSBzeW50aGVzaXplZCBub2RlcyBvbmx5IGNvbWUgZnJvbSB0aGUgdGVtcGxhdGUgY29tcGlsZXIgYW5kIHRoZXlcbiAgICAvLyB3aWxsIGFsd2F5cyBjb250YWluIHBsYWNlaG9sZGVyIG5hbWUgaW5mb3JtYXRpb24uXG4gICAgLy8gU28gdGhlcmUgd2lsbCBiZSBubyBlc2NhcGVkIHBsYWNlaG9sZGVyIG1hcmtlciBjaGFyYWN0ZXIgKGA6YCkgZGlyZWN0bHkgYWZ0ZXIgYSBzdWJzdGl0dXRpb24uXG4gICAgaWYgKChtZXNzYWdlUGFydHMucmF3W2ldIHx8IG1lc3NhZ2VQYXJ0KS5jaGFyQXQoMCkgPT09IFBMQUNFSE9MREVSX05BTUVfTUFSS0VSKSB7XG4gICAgICBjb25zdCBlbmRPZlBsYWNlaG9sZGVyTmFtZSA9IG1lc3NhZ2VQYXJ0LmluZGV4T2YoUExBQ0VIT0xERVJfTkFNRV9NQVJLRVIsIDEpO1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXJOYW1lID0gbWVzc2FnZVBhcnQuc3Vic3RyaW5nKDEsIGVuZE9mUGxhY2Vob2xkZXJOYW1lKTtcbiAgICAgIHRyYW5zbGF0aW9uS2V5ICs9IGB7JCR7cGxhY2Vob2xkZXJOYW1lfX0ke21lc3NhZ2VQYXJ0LnN1YnN0cmluZyhlbmRPZlBsYWNlaG9sZGVyTmFtZSArIDEpfWA7XG4gICAgICByZXBsYWNlbWVudHNbcGxhY2Vob2xkZXJOYW1lXSA9IGV4cHJlc3Npb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyTmFtZSA9IGBwaF8ke2l9YDtcbiAgICAgIHRyYW5zbGF0aW9uS2V5ICs9IGB7JCR7cGxhY2Vob2xkZXJOYW1lfX0ke21lc3NhZ2VQYXJ0fWA7XG4gICAgICByZXBsYWNlbWVudHNbcGxhY2Vob2xkZXJOYW1lXSA9IGV4cHJlc3Npb247XG4gICAgfVxuICB9XG4gIHJldHVybiB7dHJhbnNsYXRpb25LZXksIHN1YnN0aXR1dGlvbnM6IHJlcGxhY2VtZW50c307XG59XG4iXX0=