{"version":3,"file":"localize.js","sources":["../../../../../../packages/localize/src/global.ts","../../../../../../packages/localize/src/localize.ts","../../../../../../packages/localize/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// **********************************************************************************************\n// This code to access the global object is mostly copied from `packages/core/src/util/global.ts`\n\ndeclare global {\n  var WorkerGlobalScope: any;\n}\n\nconst __globalThis = typeof globalThis !== 'undefined' && globalThis;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n// Always use __globalThis if available; this is the spec-defined global variable across all\n// environments.\n// Then fallback to __global first; in Node tests both __global and __window may be defined.\nexport const _global: any = __globalThis || __global || __window || __self;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst PLACEHOLDER_NAME_MARKER = ':';\n\nexport interface LocalizeFn {\n  (messageParts: TemplateStringsArray, ...expressions: readonly any[]): string;\n\n  /**\n   * A function that converts an input \"message with expressions\" into a translated \"message with\n   * expressions\".\n   *\n   * The conversion may be done in place, modifying the array passed to the function, so\n   * don't assume that this has no side-effects.\n   *\n   * The expressions must be passed in since it might be they need to be reordered for\n   * different translations.\n   */\n  translate?: TranslateFn;\n}\n\nexport interface TranslateFn {\n  (messageParts: TemplateStringsArray,\n   expressions: readonly any[]): [TemplateStringsArray, readonly any[]];\n}\n\n/**\n * Tag a template literal string for localization.\n *\n * For example:\n *\n * ```ts\n * $localize `some string to localize`\n * ```\n *\n * **Naming placeholders**\n *\n * If the template literal string contains expressions then you can optionally name the placeholder\n * associated with each expression. Do this by providing the placeholder name wrapped in `:`\n * characters directly after the expression. These placeholder names are stripped out of the\n * rendered localized string.\n *\n * For example, to name the `item.length` expression placeholder `itemCount` you write:\n *\n * ```ts\n * $localize `There are ${item.length}:itemCount: items`;\n * ```\n *\n * If you need to use a `:` character directly an expression you must either provide a name or you\n * can escape the `:` by preceding it with a backslash:\n *\n * For example:\n *\n * ```ts\n * $localize `${label}:label:: ${}`\n * // or\n * $localize `${label}\\: ${}`\n * ```\n *\n * **Processing localized strings:**\n *\n * There are three scenarios:\n *\n * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a transpiler,\n * removing the tag and replacing the template literal string with a translated literal string\n * from a collection of translations provided to the transpilation tool.\n *\n * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and reorders\n * the parts (static strings and expressions) of the template literal string with strings from a\n * collection of translations loaded at run-time.\n *\n * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n * the original template literal string without applying any translations to the parts. This version\n * is used during development or where there is no need to translate the localized template\n * literals.\n *\n * @param messageParts a collection of the static parts of the template string.\n * @param expressions a collection of the values of each placeholder in the template string.\n * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n */\nexport const $localize: LocalizeFn = function(\n    messageParts: TemplateStringsArray, ...expressions: readonly any[]) {\n  if ($localize.translate) {\n    // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n    const translation = $localize.translate(messageParts, expressions);\n    messageParts = translation[0];\n    expressions = translation[1];\n  }\n  let message = messageParts[0];\n  for (let i = 1; i < messageParts.length; i++) {\n    message += expressions[i - 1] + stripPlaceholderName(messageParts[i], messageParts.raw[i]);\n  }\n  return message;\n};\n\n/**\n * Strip the placeholder name from the start of the `messagePart`, if it is found.\n *\n * Placeholder marker characters (:) may appear after a substitution that does not provide an\n * explicit placeholder name. In this case the character must be escaped with a backslash, `\\:`.\n * We can check for this by looking at the `raw` messagePart, which should still contain the\n * backslash.\n *\n * If the template literal was synthesized then its raw array will only contain empty strings.\n * This is because TS needs the original source code to find the raw text and in the case of\n * synthesize AST nodes, there is no source code.\n *\n * The workaround is to assume that the template literal did not contain an escaped placeholder\n * name, and fall back on checking the cooked array instead.\n *\n * This should be OK because synthesized nodes (from the Angular template compiler) will always\n * provide explicit placeholder names and so will never need to escape placeholder name markers.\n *\n * @param messagePart The cooked message part to process.\n * @param rawMessagePart The raw message part to check.\n * @returns the message part with the placeholder name stripped, if found.\n */\nfunction stripPlaceholderName(messagePart: string, rawMessagePart: string) {\n  return (rawMessagePart || messagePart).charAt(0) === PLACEHOLDER_NAME_MARKER ?\n      messagePart.substring(messagePart.indexOf(PLACEHOLDER_NAME_MARKER, 1) + 1) :\n      messagePart;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {_global} from './src/global';\nimport {$localize as _localize, LocalizeFn, TranslateFn} from './src/localize';\n\n// Attach $localize to the global context, as a side-effect of this module.\n_global.$localize = _localize;\n\nexport {LocalizeFn, TranslateFn};\n\n// `declare global` allows us to escape the current module and place types on the global namespace\ndeclare global {\n  /**\n   * Tag a template literal string for localization.\n   *\n   * For example:\n   *\n   * ```ts\n   * $localize `some string to localize`\n   * ```\n   *\n   * **Naming placeholders**\n   *\n   * If the template literal string contains expressions then you can optionally name the\n   * placeholder\n   * associated with each expression. Do this by providing the placeholder name wrapped in `:`\n   * characters directly after the expression. These placeholder names are stripped out of the\n   * rendered localized string.\n   *\n   * For example, to name the `item.length` expression placeholder `itemCount` you write:\n   *\n   * ```ts\n   * $localize `There are ${item.length}:itemCount: items`;\n   * ```\n   *\n   * If you need to use a `:` character directly an expression you must either provide a name or you\n   * can escape the `:` by preceding it with a backslash:\n   *\n   * For example:\n   *\n   * ```ts\n   * $localize `${label}:label:: ${}`\n   * // or\n   * $localize `${label}\\: ${}`\n   * ```\n   *\n   * **Processing localized strings:**\n   *\n   * There are three scenarios:\n   *\n   * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n   * transpiler,\n   * removing the tag and replacing the template literal string with a translated literal string\n   * from a collection of translations provided to the transpilation tool.\n   *\n   * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n   * reorders\n   * the parts (static strings and expressions) of the template literal string with strings from a\n   * collection of translations loaded at run-time.\n   *\n   * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n   * the original template literal string without applying any translations to the parts. This\n   * version\n   * is used during development or where there is no need to translate the localized template\n   * literals.\n   *\n   * @param messageParts a collection of the static parts of the template string.\n   * @param expressions a collection of the values of each placeholder in the template string.\n   * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n   */\n  const $localize: LocalizeFn;\n}\n"],"names":["_localize"],"mappings":";;;;;;AAAA;;;;;;;AAeA,IAAM,YAAY,GAAG,OAAO,UAAU,KAAK,WAAW,IAAI,UAAU,CAAC;AACrE,IAAM,QAAQ,GAAG,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC;AACzD,IAAM,MAAM,GAAG,OAAO,IAAI,KAAK,WAAW,IAAI,OAAO,iBAAiB,KAAK,WAAW;IAClF,IAAI,YAAY,iBAAiB,IAAI,IAAI,CAAC;AAC9C,IAAM,QAAQ,GAAG,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC;;;;AAIzD,AAAO,IAAM,OAAO,GAAQ,YAAY,IAAI,QAAQ,IAAI,QAAQ,IAAI,MAAM,CAAC;;ACvB3E;;;;;;;AAQA,IAAM,uBAAuB,GAAG,GAAG,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6EpC,AAAO,IAAM,SAAS,GAAe,UACjC,YAAkC;IAAE,qBAA8B;SAA9B,UAA8B,EAA9B,qBAA8B,EAA9B,IAA8B;QAA9B,oCAA8B;;IACpE,IAAI,SAAS,CAAC,SAAS,EAAE;;QAEvB,IAAM,WAAW,GAAG,SAAS,CAAC,SAAS,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;QACnE,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QAC9B,WAAW,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;KAC9B;IACD,IAAI,OAAO,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;IAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC5C,OAAO,IAAI,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,oBAAoB,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;KAC5F;IACD,OAAO,OAAO,CAAC;CAChB,CAAC;;;;;;;;;;;;;;;;;;;;;;;AAwBF,SAAS,oBAAoB,CAAC,WAAmB,EAAE,cAAsB;IACvE,OAAO,CAAC,cAAc,IAAI,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC,KAAK,uBAAuB;QACxE,WAAW,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,CAAC,uBAAuB,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;QAC1E,WAAW,CAAC;CACjB;;AC9HD;;;;;;;AAOA,AAGA;AACA,OAAO,CAAC,SAAS,GAAGA,SAAS,CAAC"}