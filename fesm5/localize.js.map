{"version":3,"file":"localize.js","sources":["../../../../../../packages/localize/src/utils/constants.ts","../../../../../../packages/localize/src/utils/messages.ts","../../../../../../packages/localize/src/utils/translations.ts","../../../../../../packages/localize/src/translate.ts","../../../../../../packages/localize/localize.ts","../../../../../../packages/localize/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\n * A block can indicate metadata about the message or specify a name of a placeholder for a\n * substitution expressions.\n *\n * For example:\n *\n * ```ts\n * $localize`Hello, ${title}:title:!`;\n * $localize`:meaning|description@@id:source message text`;\n * ```\n */\nexport const BLOCK_MARKER = ':';\n\n/**\n * The marker used to separate a message's \"meaning\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:correct|Indicates that the user got the answer correct: Right!`;\n * $localize `:movement|Button label for moving to the right: Right!`;\n * ```\n */\nexport const MEANING_SEPARATOR = '|';\n\n/**\n * The marker used to separate a message's custom \"id\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:A welcome message on the home page@@myApp-homepage-welcome: Welcome!`;\n * ```\n */\nexport const ID_SEPARATOR = '@@';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {computeMsgId} from '@angular/compiler';\nimport {BLOCK_MARKER, ID_SEPARATOR, MEANING_SEPARATOR} from './constants';\n\n/**\n * Re-export this helper function so that users of `@angular/localize` don't need to actively import\n * from `@angular/compiler`.\n */\nexport {computeMsgId} from '@angular/compiler';\n\n/**\n * A string containing a translation source message.\n *\n * I.E. the message that indicates what will be translated from.\n *\n * Uses `{$placeholder-name}` to indicate a placeholder.\n */\nexport type SourceMessage = string;\n\n/**\n * A string containing a translation target message.\n *\n * I.E. the message that indicates what will be translated to.\n *\n * Uses `{$placeholder-name}` to indicate a placeholder.\n */\nexport type TargetMessage = string;\n\n/**\n * A string that uniquely identifies a message, to be used for matching translations.\n */\nexport type MessageId = string;\n\n/**\n * Information parsed from a `$localize` tagged string that is used to translate it.\n *\n * For example:\n *\n * ```\n * const name = 'Jo Bloggs';\n * $localize`Hello ${name}:title!`;\n * ```\n *\n * May be parsed into:\n *\n * ```\n * {\n *   messageId: '6998194507597730591',\n *   substitutions: { title: 'Jo Bloggs' },\n * }\n * ```\n */\nexport interface ParsedMessage {\n  /**\n   * The key used to look up the appropriate translation target.\n   */\n  messageId: MessageId;\n  /**\n   * A mapping of placeholder names to substitution values.\n   */\n  substitutions: Record<string, any>;\n  /**\n   * A human readable rendering of the message\n   */\n  messageString: string;\n}\n\n/**\n * Parse a `$localize` tagged string into a structure that can be used for translation.\n *\n * See `ParsedMessage` for an example.\n */\nexport function parseMessage(\n    messageParts: TemplateStringsArray, expressions?: readonly any[]): ParsedMessage {\n  const substitutions: {[placeholderName: string]: any} = {};\n  const metadata = parseMetadata(messageParts[0], messageParts.raw[0]);\n  let messageString = metadata.text;\n  for (let i = 1; i < messageParts.length; i++) {\n    const {text: messagePart, block: placeholderName = `ph_${i}`} =\n        splitBlock(messageParts[i], messageParts.raw[i]);\n    messageString += `{$${placeholderName}}${messagePart}`;\n    if (expressions !== undefined) {\n      substitutions[placeholderName] = expressions[i - 1];\n    }\n  }\n  return {\n    messageId: metadata.id || computeMsgId(messageString, metadata.meaning || ''),\n    substitutions,\n    messageString,\n  };\n}\n\nexport interface MessageMetadata {\n  text: string;\n  meaning: string|undefined;\n  description: string|undefined;\n  id: string|undefined;\n}\n\n/**\n * Parse the given message part (`cooked` + `raw`) to extract the message metadata from the text.\n *\n * If the message part has a metadata block this function will extract the `meaning`,\n * `description` and `id` (if provided) from the block. These metadata properties are serialized in\n * the string delimited by `|` and `@@` respectively.\n *\n * For example:\n *\n * ```ts\n * `:meaning|description@@id`\n * `:meaning|@@id`\n * `:meaning|description`\n * `description@@id`\n * `meaning|`\n * `description`\n * `@@id`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing any metadata that was parsed from the message part.\n */\nexport function parseMetadata(cooked: string, raw: string): MessageMetadata {\n  const {text, block} = splitBlock(cooked, raw);\n  if (block === undefined) {\n    return {text, meaning: undefined, description: undefined, id: undefined};\n  } else {\n    const [meaningAndDesc, id] = block.split(ID_SEPARATOR, 2);\n    let [meaning, description]: (string | undefined)[] = meaningAndDesc.split(MEANING_SEPARATOR, 2);\n    if (description === undefined) {\n      description = meaning;\n      meaning = undefined;\n    }\n    if (description === '') {\n      description = undefined;\n    }\n    return {text, meaning, description, id};\n  }\n}\n\n/**\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\n * rest of the text of the message part.\n *\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\n * start and end of the block.\n *\n * If the block is in the first message part then it will be metadata about the whole message:\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\n * substitution: placeholder name.\n *\n * Since blocks are optional, it is possible that the content of a message block actually starts\n * with a block marker. In this case the marker must be escaped `\\:`.\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\n * exists.\n */\nexport function splitBlock(cooked: string, raw: string): {text: string, block?: string} {\n  // Synthesizing AST nodes that represent template literals using the TypeScript API is problematic\n  // because it doesn't allow for the raw value of messageParts to be programmatically set.\n  // The result is that synthesized AST nodes have empty `raw` values.\n\n  // Normally we rely upon checking the `raw` value to check whether the `BLOCK_MARKER` was escaped\n  // in the original source. If the `raw` value is missing then we cannot do this.\n  // In such a case we fall back on the `cooked` version and assume that the `BLOCK_MARKER` was not\n  // escaped.\n\n  // This should be OK because synthesized nodes only come from the Angular template compiler, which\n  // always provides full id and placeholder name information so it will never escape `BLOCK_MARKER`\n  // characters.\n  if ((raw || cooked).charAt(0) !== BLOCK_MARKER) {\n    return {text: cooked};\n  } else {\n    const endOfBlock = cooked.indexOf(BLOCK_MARKER, 1);\n    return {\n      block: cooked.substring(1, endOfBlock),\n      text: cooked.substring(endOfBlock + 1),\n    };\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {BLOCK_MARKER} from './constants';\nimport {MessageId, TargetMessage, parseMessage} from './messages';\n\n/**\n * A translation message that has been processed to extract the message parts and placeholders.\n */\nexport interface ParsedTranslation {\n  messageParts: TemplateStringsArray;\n  placeholderNames: string[];\n}\n\n/**\n * The internal structure used by the runtime localization to translate messages.\n */\nexport type ParsedTranslations = Record<MessageId, ParsedTranslation>;\n\n\n/**\n * Translate the text of the `$localize` tagged-string (i.e. `messageParts` and\n * `substitutions`) using the given `translations`.\n *\n * The tagged-string is parsed to extract its `messageId` which is used to find an appropriate\n * `ParsedTranslation`.\n *\n * If one is found then it is used to translate the message into a new set of `messageParts` and\n * `substitutions`.\n * The translation may reorder (or remove) substitutions as appropriate.\n *\n * If no translation matches then an error is thrown.\n */\nexport function translate(\n    translations: Record<string, ParsedTranslation>, messageParts: TemplateStringsArray,\n    substitutions: readonly any[]): [TemplateStringsArray, readonly any[]] {\n  const message = parseMessage(messageParts, substitutions);\n  const translation = translations[message.messageId];\n  if (translation !== undefined) {\n    return [\n      translation.messageParts,\n      translation.placeholderNames.map(placeholder => message.substitutions[placeholder])\n    ];\n  } else {\n    throw new Error(\n        `No translation found for \"${message.messageId}\" (\"${message.messageString}\").`);\n  }\n}\n\n/**\n * Parse the `messageParts` and `placeholderNames` out of a target `message`.\n *\n * Used by `loadTranslations()` to convert target message strings into a structure that is more\n * appropriate for doing translation.\n *\n * @param message the message to be parsed.\n */\nexport function parseTranslation(message: TargetMessage): ParsedTranslation {\n  const parts = message.split(/{\\$([^}]*)}/);\n  const messageParts = [parts[0]];\n  const placeholderNames: string[] = [];\n  for (let i = 1; i < parts.length - 1; i += 2) {\n    placeholderNames.push(parts[i]);\n    messageParts.push(`${parts[i + 1]}`);\n  }\n  const rawMessageParts =\n      messageParts.map(part => part.charAt(0) === BLOCK_MARKER ? '\\\\' + part : part);\n  return {messageParts: makeTemplateObject(messageParts, rawMessageParts), placeholderNames};\n}\n\n/**\n * Create the specialized array that is passed to tagged-string tag functions.\n *\n * @param cooked The message parts with their escape codes processed.\n * @param raw The message parts with their escaped codes as-is.\n */\nexport function makeTemplateObject(cooked: string[], raw: string[]): TemplateStringsArray {\n  Object.defineProperty(cooked, 'raw', {value: raw});\n  return cooked as any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {LocalizeFn} from './localize';\nimport {MessageId, TargetMessage} from './utils/messages';\nimport {ParsedTranslation, parseTranslation, translate as _translate} from './utils/translations';\n\n/**\n * We augment the `$localize` object to also store the translations.\n *\n * Note that because the TRANSLATIONS are attached to a global object, they will be shared between\n * all applications that are running in a single page of the browser.\n */\ndeclare const $localize: LocalizeFn&{TRANSLATIONS: Record<MessageId, ParsedTranslation>};\n\n/**\n * Load translations for `$localize`.\n *\n * The given `translations` are processed and added to a lookup based on their `MessageId`.\n * A new translation will overwrite a previous translation if it has the same `MessageId`.\n *\n * * If a message is generated by the Angular compiler from an `i18n` marker in a template, the\n *   `MessageId` is passed through to the `$localize` call as a custom `MessageId`. The `MessageId`\n *   will match what is extracted into translation files.\n *\n * * If the translation is from a call to `$localize` in application code, and no custom `MessageId`\n *   is provided, then the `MessageId` can be generated by passing the tagged string message-parts\n *   to the `parseMessage()` function (not currently public API).\n *\n * @publicApi\n *\n */\nexport function loadTranslations(translations: Record<MessageId, TargetMessage>) {\n  // Ensure the translate function exists\n  if (!$localize.translate) {\n    $localize.translate = translate;\n  }\n  if (!$localize.TRANSLATIONS) {\n    $localize.TRANSLATIONS = {};\n  }\n  Object.keys(translations).forEach(key => {\n    $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);\n  });\n}\n\n/**\n * Remove all translations for `$localize`.\n *\n * @publicApi\n */\nexport function clearTranslations() {\n  $localize.TRANSLATIONS = {};\n}\n\n/**\n * Translate the text of the given message, using the loaded translations.\n *\n * This function may reorder (or remove) substitutions as indicated in the matching translation.\n */\nexport function translate(messageParts: TemplateStringsArray, substitutions: readonly any[]):\n    [TemplateStringsArray, readonly any[]] {\n  try {\n    return _translate($localize.TRANSLATIONS, messageParts, substitutions);\n  } catch (e) {\n    console.warn(e.message);\n    return [messageParts, substitutions];\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file contains the public API of the `@angular/localize` entry-point\n\nexport {clearTranslations, loadTranslations} from './src/translate';","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// DO NOT ADD public exports to this file.\n// The public API exports are specified in the `./localize` module, which is checked by the\n// public_api_guard rules\n\nexport * from './localize';\n"],"names":["translate","_translate"],"mappings":"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"}